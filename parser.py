# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15MspuC6ZmsmluX4LSS92pNKRZUT4y5Bs
"""

class RecursiveDescentParser:
    def __init__(self):
        self.grammar_rules = {}  # ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±
        self.non_terminals = []
        self.stack = []
        self.input_string = []
        self.accepted = False

    def set_grammar(self):  # ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿØÿßŸÑÿ©
        print("üë®‚Äçüíª *** Enter Grammar Definition *** üë©‚Äçüíª")
        self.grammar_rules.clear()
        self.non_terminals = []
        num_non_terminals = int(input("How many non-terminals would you like to define? "))

        for _ in range(num_non_terminals):
            nt = input("Enter a non-terminal symbol: ").strip()
            self.non_terminals.append(nt)
            rules = []
            print(f"Provide rules for the non-terminal '{nt}' (type 'end' to finish):")
            while True:
                rule = input(">> ").strip()
                if rule.lower() == 'end':
                    break
                rules.append(rule)
            self.grammar_rules[nt] = rules

    def is_simple_grammar(self):
        for rules in self.grammar_rules.values():
            for rule in rules:
                if rule.startswith(tuple(self.non_terminals)):
                    return False
        return True

    def parse(self, current, position):
        if position == len(self.input_string) and current == "":
            return True
        if current == "" or position == len(self.input_string):
            return False

        next_symbol = current[0]
        if next_symbol in self.grammar_rules:  # Non-terminal
            for rule in self.grammar_rules[next_symbol]:
                if self.parse(rule + current[1:], position):
                    self.stack.append((next_symbol, rule))
                    return True
        elif position < len(self.input_string) and next_symbol == self.input_string[position]:  # Terminal match
            return self.parse(current[1:], position + 1)
        return False

    def check_string(self, input_str):
        self.input_string = input_str
        self.stack.clear()
        self.accepted = self.parse(self.non_terminals[0], 0)  # Start with the first non-terminal
        return self.accepted

    def print_tree(self):
        print("\nüå≥ **Parsing Tree** üå≥")
        for nt, rule in reversed(self.stack):
            print(f"{nt} -> {rule}")
        print()

    def menu(self):
        while True:
            print("\n---------------------------")
            print("1. Enter Another Grammar")
            print("2. Check Another String")
            print("3. Exit Program")
            choice = input("Please select an option: ")
            if choice == '1':
                self.set_grammar()
                if self.is_simple_grammar():
                    print("‚úÖ Grammar is simple and valid!")
                else:
                    print("‚ö†Ô∏è Grammar is not simple. Please try again.")
                    continue
            elif choice == '2':
                input_str = input("Enter the string you want to check: ")
                input_list = list(input_str)
                print(f"\nChecking the input string: {input_list}")
                if self.check_string(input_list):
                    print("‚úÖ Your input string is ACCEPTED.")
                    self.print_tree()
                else:
                    print("‚ùå Your input string is REJECTED.")
            elif choice == '3':
                print("Exiting... Goodbye!")
                break
            else:
                print("‚ö†Ô∏è Invalid choice. Please try again.")

if __name__ == "__main__":
    parser = RecursiveDescentParser()
    parser.set_grammar()
    while not parser.is_simple_grammar():
        print("‚ö†Ô∏è Grammar is not simple. Please try again.")
        parser.set_grammar()
    print("‚úÖ Grammar is simple and valid!")
    parser.menu()